generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id                  String               @id @default(cuid())
  email               String               @unique
  passwordHash        String
  name                String
  role                Role                 @default(CLIENT)
  isActive            Boolean              @default(true)
  deletedAt           DateTime?
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  accountant          Accountant?
  activityLogs        ActivityLog[]
  client              Client?
  uploadedDocuments   Document[]
  passwordResetTokens PasswordResetToken[]
  refreshTokens       RefreshToken[]

  @@map("users")
}

model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("refresh_tokens")
}

model Accountant {
  id                   String             @id @default(cuid())
  userId               String             @unique
  companyName          String
  cnpj                 String             @unique
  crc                  String
  phone                String?
  stripeCustomerId     String?            @unique
  stripeSubscriptionId String?            @unique
  subscriptionStatus   SubscriptionStatus @default(TRIALING)
  subscriptionPlan     String?
  trialEndsAt          DateTime?
  onboardingCompleted  Boolean            @default(false)
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  clients              Client[]
  invitations          Invitation[]
  notifications        Notification[]
  payments             Payment[]
  subscription         Subscription?

  @@index([cnpj])
  @@map("accountants")
}

model Client {
  id                   String            @id @default(cuid())
  userId               String            @unique
  accountantId         String
  companyName          String?
  cpfCnpj              String            @unique
  phone                String?
  expenseModuleEnabled Boolean           @default(false)
  deletedAt            DateTime?
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  activityLogs         ActivityLog[]
  accountant           Accountant        @relation(fields: [accountantId], references: [id], onDelete: Cascade)
  user                 User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  documentFolders      DocumentFolder[]
  requests             DocumentRequest[]
  documents            Document[]
  expenses             Expense[]
  notifications        Notification[]
  payments             Payment[]

  @@index([accountantId])
  @@index([cpfCnpj])
  @@map("clients")
}

model DocumentFolder {
  id          String     @id @default(cuid())
  clientId    String
  name        String
  type        FolderType
  icon        String?
  color       String?
  description String?
  sortOrder   Int        @default(0)
  isDefault   Boolean    @default(false)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  client      Client     @relation(fields: [clientId], references: [id], onDelete: Cascade)
  documents   Document[]

  @@index([clientId])
  @@index([type])
  @@map("document_folders")
}

model Document {
  id                 String            @id @default(cuid())
  clientId           String
  requestId          String?
  type               DocumentType
  title              String
  description        String?
  filePath           String
  fileName           String
  mimeType           String
  fileSize           Int
  createdById        String
  deletedAt          DateTime?
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  folderId           String?
  client             Client            @relation(fields: [clientId], references: [id], onDelete: Cascade)
  createdBy          User              @relation(fields: [createdById], references: [id], onDelete: Cascade)
  folder             DocumentFolder?   @relation(fields: [folderId], references: [id])
  request            DocumentRequest?  @relation(fields: [requestId], references: [id])
  paymentAttachments PaymentDocument[]

  @@index([clientId])
  @@index([folderId])
  @@index([requestId])
  @@index([type])
  @@index([createdAt])
  @@index([createdById])
  @@map("documents")
}

model Payment {
  id                  String              @id @default(cuid())
  clientId            String?
  accountantId        String
  paymentType         PaymentType         @default(CLIENT)
  title               String
  amount              Decimal             @db.Decimal(10, 2)
  paymentDate         DateTime?
  dueDate             DateTime
  paymentMethod       PaymentMethod?
  reference           String?
  notes               String?
  status              PaymentStatus       @default(PENDING)
  receiptPath         String?
  fileName            String?
  mimeType            String?
  fileSize            Int?
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  isRecurring         Boolean             @default(false)
  parentPaymentId     String?
  recurringDayOfMonth Int?
  recurringEndDate    DateTime?
  recurringFrequency  RecurringFrequency?
  invoiceAttachedAt   DateTime?
  invoiceAttachedBy   String?
  requiresInvoice     Boolean             @default(false)
  attachedDocuments   PaymentDocument[]
  accountant          Accountant          @relation(fields: [accountantId], references: [id], onDelete: Cascade)
  client              Client?             @relation(fields: [clientId], references: [id])
  parentPayment       Payment?            @relation("RecurringPayments", fields: [parentPaymentId], references: [id])
  childPayments       Payment[]           @relation("RecurringPayments")

  @@index([clientId])
  @@index([accountantId])
  @@index([paymentType])
  @@index([status])
  @@index([dueDate])
  @@index([paymentDate])
  @@index([isRecurring])
  @@index([parentPaymentId])
  @@map("payments")
}

model PaymentDocument {
  id         String   @id @default(cuid())
  paymentId  String
  documentId String
  attachedAt DateTime @default(now())
  attachedBy String
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  payment    Payment  @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@unique([paymentId, documentId])
  @@index([paymentId])
  @@index([documentId])
  @@map("payment_documents")
}

model Expense {
  id          String          @id @default(cuid())
  clientId    String
  category    ExpenseCategory
  description String
  amount      Decimal         @db.Decimal(10, 2)
  date        DateTime
  receiptPath String?
  fileName    String?
  mimeType    String?
  fileSize    Int?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  client      Client          @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([date])
  @@index([category])
  @@map("expenses")
}

model DocumentRequest {
  id          String        @id @default(cuid())
  clientId    String
  type        String
  description String
  status      RequestStatus @default(PENDING)
  dueDate     DateTime?
  fulfilledAt DateTime?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  client      Client        @relation(fields: [clientId], references: [id], onDelete: Cascade)
  documents   Document[]

  @@index([clientId])
  @@index([status])
  @@map("document_requests")
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@map("password_reset_tokens")
}

model ActivityLog {
  id          String   @id @default(cuid())
  clientId    String
  userId      String
  action      String
  description String
  metadata    Json?
  createdAt   DateTime @default(now())
  client      Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([userId])
  @@index([createdAt])
  @@map("activity_logs")
}

model Notification {
  id           String           @id @default(cuid())
  clientId     String?
  type         NotificationType
  title        String
  message      String
  isRead       Boolean          @default(false)
  metadata     Json?
  createdAt    DateTime         @default(now())
  readAt       DateTime?
  accountantId String?
  accountant   Accountant?      @relation(fields: [accountantId], references: [id], onDelete: Cascade)
  client       Client?          @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([accountantId])
  @@index([isRead])
  @@index([createdAt])
  @@map("notifications")
}

model Plan {
  id                   String         @id @default(cuid())
  name                 String
  slug                 String         @unique
  description          String?
  tenantType           TenantType
  priceMonthly         Decimal        @db.Decimal(10, 2)
  priceYearly          Decimal        @db.Decimal(10, 2)
  stripePriceIdMonthly String?        @unique
  stripePriceIdYearly  String?        @unique
  stripeProductId      String?        @unique
  limitsJson           Json
  featuresJson         Json
  isActive             Boolean        @default(true)
  sortOrder            Int            @default(0)
  createdAt            DateTime       @default(now())
  updatedAt            DateTime       @updatedAt
  subscriptions        Subscription[]

  @@index([slug])
  @@index([tenantType])
  @@index([isActive])
  @@map("plans")
}

model Subscription {
  id                   String             @id @default(cuid())
  accountantId         String             @unique
  planId               String
  status               SubscriptionStatus @default(TRIALING)
  interval             BillingInterval    @default(MONTHLY)
  stripeSubscriptionId String?            @unique
  stripeCustomerId     String?
  currentPeriodStart   DateTime
  currentPeriodEnd     DateTime
  trialEnd             DateTime?
  canceledAt           DateTime?
  cancelAtPeriodEnd    Boolean            @default(false)
  metadata             Json?
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  invoices             Invoice[]
  accountant           Accountant         @relation(fields: [accountantId], references: [id], onDelete: Cascade)
  plan                 Plan               @relation(fields: [planId], references: [id])
  usageRecords         UsageRecord[]

  @@index([accountantId])
  @@index([planId])
  @@index([status])
  @@index([stripeSubscriptionId])
  @@map("subscriptions")
}

model Invoice {
  id                    String        @id @default(cuid())
  subscriptionId        String
  stripeInvoiceId       String?       @unique
  stripePaymentIntentId String?       @unique
  invoiceNumber         String        @unique
  status                InvoiceStatus @default(OPEN)
  amount                Decimal       @db.Decimal(10, 2)
  currency              String        @default("BRL")
  periodStart           DateTime
  periodEnd             DateTime
  dueDate               DateTime?
  paidAt                DateTime?
  voidedAt              DateTime?
  invoicePdfUrl         String?
  hostedInvoiceUrl      String?
  metadata              Json?
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt
  subscription          Subscription  @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@index([status])
  @@index([stripeInvoiceId])
  @@index([createdAt])
  @@map("invoices")
}

model UsageRecord {
  id             String       @id @default(cuid())
  subscriptionId String
  paymentsCount  Int          @default(0)
  expensesCount  Int          @default(0)
  documentsCount Int          @default(0)
  storageUsedMB  Int          @default(0)
  periodStart    DateTime
  periodEnd      DateTime
  metadata       Json?
  createdAt      DateTime     @default(now())
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@index([periodStart])
  @@map("usage_records")
}

model Invitation {
  id           String     @id @default(cuid())
  accountantId String
  email        String
  name         String?
  cpfCnpj      String?
  token        String     @unique
  expiresAt    DateTime
  acceptedAt   DateTime?
  createdAt    DateTime   @default(now())
  accountant   Accountant @relation(fields: [accountantId], references: [id], onDelete: Cascade)

  @@index([accountantId])
  @@index([token])
  @@index([email])
  @@map("invitations")
}

enum Role {
  ADMIN
  ACCOUNTANT
  CLIENT
}

enum SubscriptionStatus {
  TRIALING
  ACTIVE
  PAST_DUE
  CANCELED
  EXPIRED
  INCOMPLETE
}

enum DocumentType {
  NFE
  NFSE
  CTE
  RECEIPT
  CONTRACT
  BANK_STATEMENT
  STATEMENT
  OTHER
}

enum PaymentStatus {
  PENDING
  PAID
  OVERDUE
  CANCELED
  AWAITING_INVOICE
  READY_TO_PAY
  AWAITING_VALIDATION
}

enum RequestStatus {
  PENDING
  FULFILLED
  EXPIRED
}

enum PaymentMethod {
  CASH
  PIX
  BANK_TRANSFER
  CREDIT_CARD
  DEBIT_CARD
  BOLETO
}

enum PaymentType {
  CLIENT
  OFFICE
}

enum RecurringFrequency {
  MONTHLY
  QUARTERLY
  SEMIANNUAL
  YEARLY
}

enum NotificationType {
  DOCUMENT_AVAILABLE
  DOCUMENT_REQUESTED
  PAYMENT_REGISTERED
  PAYMENT_OVERDUE
}

enum ExpenseCategory {
  FOOD
  TRANSPORT
  HEALTH
  EDUCATION
  OTHER
}

enum FolderType {
  NOTAS_FISCAIS
  CONTRATOS
  DECLARACOES
  COMPROVANTES
  BALANCETES
  OUTROS
}

enum BillingInterval {
  MONTHLY
  YEARLY
}

enum TenantType {
  INDIVIDUAL
  ACCOUNTANT_FIRM
}

enum InvoiceStatus {
  DRAFT
  OPEN
  PAID
  VOID
  UNCOLLECTIBLE
}
